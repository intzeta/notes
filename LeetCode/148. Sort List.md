[148. Sort List](https://leetcode.com/problems/sort-list/)
[[Linked List]]
[[Two Pointers]]
[[Sorting Algorithms]]

Given the `head` of a linked list, return _the list after sorting it in **ascending order**_.

**Example 1:**

![[LeetCode148_1.jpg]]

`Input: head = [4,2,1,3]
`Output: [1,2,3,4]

**Example 2:**

![[LeetCode148_2.jpg]]

`Input: head = [-1,5,3,4,0]
`Output: [-1,0,3,4,5]

**Example 3:**

`Input: head = []
`Output: []

**Constraints:**

- The number of nodes in the list is in the range `[0, 5 * 104]`.
- `-105 <= Node.val <= 105`

**Follow up:** Can you sort the linked list in `O(n logn)` time and `O(1)` memory (i.e. constant space)?

##### Answer And Explanation

- In this function we divide the Linked List into Left Side of the Linked List and a Right Side. The base condition in this recursive function is the if statement that checks if there is only one element in the Linked List.

- Then we declare the slow and fast ListNode's 

```
ListNode* sortList(ListNode* head){
        if(head == nullptr || head->next == NULL){
            return head;
        }

        ListNode* slow = head;
        ListNode* fast = head->next->next;

        while(fast != nullptr && fast->next != nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode* RightSide = sortList(slow->next);
        slow->next = NULL;
        ListNode* LeftSide = sortList(head);

        return merge(LeftSide, RightSide);
         
    }
```


```
    ListNode* merge(ListNode* leftList, ListNode* rightList){
        ListNode* dummy = new ListNode(0);
        ListNode* temp = dummy;

        while(leftList != nullptr && rightList != nullptr){
            if(leftList->val <= rightList->val){
                temp->next = leftList;
                leftList = leftList->next;
            }else{
                temp->next = rightList;
                rightList = rightList->next;
            }
            temp = temp->next;
        } 

        if(leftList){
            temp->next = leftList;
        }else{
            temp->next = rightList;
        }
        return dummy->next;
    } 
```